--- state_machine.py.orig
+++ state_machine.py
@@ -7,6 +7,7 @@
 from pathlib import Path
 from types import SimpleNamespace as _SNS

 from playwright_driver import playwright_driver
+import logging

 # ============== Paths & Data dirs ==============
 DATA_DIR = Path("/app/data")
@@ -30,6 +31,26 @@
 }
 _lock = asyncio.Lock()

+# === Manual gates so FE/operator can confirm before next step ===
+_gates = {}  # name -> asyncio.Event
+
+logger = logging.getLogger(__name__)
+
+def gate_reset(name):
+    """Reset gate to closed state"""
+    _gates[name] = asyncio.Event()
+    logger.info(f"[GATE] Reset gate: {name}")
+
+def gate_open(name):
+    """Open gate to allow proceeding"""
+    _gates[name].set()
+    logger.info(f"[GATE] Opened gate: {name}")
+
+async def gate_wait(name, timeout=None):
+    """Wait for gate to open with optional timeout"""
+    ev = _gates.get(name)
+    if not ev:
+        _gates[name] = asyncio.Event()
+        ev = _gates[name]
+    try:
+        await asyncio.wait_for(ev.wait(), timeout=timeout)
+        logger.info(f"[GATE] Gate opened: {name}")
+    except asyncio.TimeoutError:
+        logger.warning(f"[GATE] Gate timeout: {name} ({timeout}s)")
+        raise
+
 # current_session_obj: đối tượng *để app.py truy cập như thuộc tính*
 # (app.py gọi: state_machine.current_session.id / .current_state ...)
 current_session_obj = _SNS(
@@ -109,6 +130,9 @@
 async def _s1_open_product_and_open_chat(page, product_url: str):
     _state["step"] = "S1_OPEN_PRODUCT_AND_OPEN_CHAT"
     _save_session_snapshot()
+    logger.info(f"[STATE] S1: Opening product and chat - {product_url}")
     await playwright_driver.open_chat_from_product_canonical(page, product_url)
     # Chờ thấy ô chat trước khi sang S2 để tránh "No chat input found"
     await playwright_driver.wait_for_chat_ready(page, timeout_s=25)
+    logger.info("[STATE] S1: Product opened and chat ready")

 async def _s2_send_opener(page, opener_text: str):
     _state["step"] = "S2_SEND_OPENER"
     _save_session_snapshot()
+    logger.info(f"[STATE] S2: Sending opener message")
     await playwright_driver.send_on_chat_precise_canonical(page, opener_text)
+    logger.info("[STATE] S2: Opener message sent successfully")

 async def _s3_wait_reply(page):
     _state["step"] = "S3_WAIT_SUPPLIER_REPLY"
     _save_session_snapshot()
+    logger.info("[STATE] S3: Waiting for supplier reply")
     reply = await playwright_driver.wait_for_supplier_reply_canonical(page, timeout_s=180)
     _state["reply"] = reply
     _save_session_snapshot()
@@ -152,6 +176,8 @@
 async def start(product_url: str, opener_text: str, max_turns: int = 6, style: str = "Aggressive"):
     """Bắt đầu 1 phiên thương lượng (one-shot)."""
+    logger.info(f"[STATE] Starting negotiation - Product: {product_url}, Style: {style}")
+
     async with _lock:
         if _state["status"] == "running":
+            logger.warning("[STATE] Another session is already running")
             raise RuntimeError("A session is already running")

         # init state
@@ -190,6 +216,7 @@
         # 2) Ensure login mà không điều hướng sản phẩm (để S1 xử lý)
         await playwright_driver.ensure_login_via_taobao(
             page,
             timeout_s=300,
             next_url=None,
             force_show_login=True
         )

+        logger.info("[STATE] S0: Login completed")
+        # Gate sau khi login xong
+        _state["step"] = "S0_DONE"
+        _save_session_snapshot()
+        gate_reset("CONFIRM_AFTER_LOGIN")
+        logger.info("[STATE] S0_DONE — waiting gate CONFIRM_AFTER_LOGIN")
+        try:
+            await gate_wait("CONFIRM_AFTER_LOGIN", timeout=20)
+        except asyncio.TimeoutError:
+            logger.info("[GATE] CONFIRM_AFTER_LOGIN timeout → auto proceed")

         # 3) Product + Chat
         await _s1_open_product_and_open_chat(page, product_url)
+        logger.info("[STATE] S1: Product and chat completed")
+        # Gate sau khi vào sản phẩm và mở chat
+        _state["step"] = "S1_DONE"
+        _save_session_snapshot()
+        gate_reset("CONFIRM_PRODUCT_AND_CHAT")
+        logger.info("[STATE] S1_DONE — waiting gate CONFIRM_PRODUCT_AND_CHAT")
+        try:
+            await gate_wait("CONFIRM_PRODUCT_AND_CHAT", timeout=20)
+        except asyncio.TimeoutError:
+            logger.info("[GATE] CONFIRM_PRODUCT_AND_CHAT timeout → auto proceed")

         # 4) Send opener
         await _s2_send_opener(page, opener_text)
+        logger.info("[STATE] S2: Opener sent completed")
+        # Gate sau khi gửi opener
+        _state["step"] = "S2_DONE"
+        _save_session_snapshot()
+        gate_reset("CONFIRM_AFTER_SEND")
+        logger.info("[STATE] S2_DONE — waiting gate CONFIRM_AFTER_SEND")
+        try:
+            await gate_wait("CONFIRM_AFTER_SEND", timeout=20)
+        except asyncio.TimeoutError:
+            logger.info("[GATE] CONFIRM_AFTER_SEND timeout → auto proceed")

         # 5) Wait reply
         await _s3_wait_reply(page)
+        logger.info("[STATE] S3: Supplier reply received")

         # 6) Persist storage state
         await playwright_driver.persist_state(_state["_context"])
@@ -199,6 +226,7 @@
         _state["status"] = "done"
         _state["step"] = "DONE"
         _state["finished_at"] = datetime.utcnow().isoformat() + "Z"
         _save_session_snapshot()
+        logger.info("[STATE] Negotiation completed successfully")
         return {"session_id": _state["session_id"], "status": _state["status"], "reply": _state["reply"]}

     except Exception as e:
+        logger.error(f"[STATE] Error during negotiation: {e}")
         _state["status"] = "error"
         _state["last_error"] = f"{type(e).__name__}: {e}"
         _state["finished_at"] = datetime.utcnow().isoformat() + "Z"
@@ -206,6 +234,7 @@
     finally:
         # close browser if opened
         try:
+            logger.info("[STATE] Cleaning up browser resources")
             if _state.get("_pw") and _state.get("_browser"):
                 await playwright_driver.stop(_state["_pw"], _state["_browser"])
         finally:
             for k in ("_pw", "_browser", "_context", "_page"):
                 _state.pop(k, None)
             _save_session_snapshot()
@@ -243,6 +272,7 @@
 async def start_login_only():
     """Start login-only session that stops at Work Home."""
+    logger.info("[STATE] Starting login-only session")
     async with _lock:
         if _state["status"] == "running":
+            logger.warning("[STATE] Another session is already running")
             raise RuntimeError("A session is already running")

         # init state
@@ -268,6 +298,7 @@
         )

         # Persist storage state
+        logger.info("[STATE] Login-only session completed")
         await playwright_driver.persist_state(_state["_context"])

         _state["step"] = "READY_FOR_PRODUCT"
@@ -280,6 +311,7 @@
     except Exception as e:
+        logger.error(f"[STATE] Error in login-only session: {e}")
         _state["status"] = "error"
         _state["last_error"] = f"{type(e).__name__}: {e}"
         _state["finished_at"] = datetime.utcnow().isoformat() + "Z"
@@ -309,6 +341,7 @@
 async def goto_product(product_url_raw: str):
     """Navigate to product URL with existing session."""
+    logger.info(f"[STATE] Navigating to product: {product_url_raw}")
     async with _lock:
         if _state["status"] != "running" or _state.get("step") != "READY_FOR_PRODUCT":
+            logger.error("[STATE] No active ready session for product navigation")
             raise RuntimeError("No active ready session. Call login-only first.")

         if not _state.get("_page"):
+            logger.error("[STATE] No active browser page")
             raise RuntimeError("No active browser page")

@@ -330,6 +363,7 @@
         # Update state
         _state["product_url"] = product_url
         _state["step"] = "AT_PRODUCT"
         _save_session_snapshot()
+        logger.info(f"[STATE] Successfully navigated to product: {product_url}")

         return {
             "ok": True,
@@ -339,6 +373,7 @@
     except Exception as e:
+        logger.error(f"[STATE] Error navigating to product: {e}")
         _state["status"] = "error"
         _state["last_error"] = f"{type(e).__name__}: {e}"
         _save_session_snapshot()
@@ -349,6 +384,7 @@
 async def cancel():
+    logger.info("[STATE] Cancelling current session")
     async with _lock:
         try:
             if _state.get("_pw") and _state.get("_browser"):
+                logger.info("[STATE] Stopping browser")
                 await playwright_driver.stop(_state["_pw"], _state["_browser"])
         finally:
             for k in ("_pw", "_browser", "_context", "_page"):
                 _state.pop(k, None)
             _state["status"] = "cancelled"
             _state["step"] = "CANCELLED"
             _state["finished_at"] = datetime.utcnow().isoformat() + "Z"
             _save_session_snapshot()
+        logger.info("[STATE] Session cancelled")

 # ============== Export object that app.py imports ==============
@@ -389,6 +425,9 @@
     start_login_only=start_login_only,
     goto_product=goto_product,
     # Gate functions for manual control
+    gate_open=gate_open,
+    gate_reset=gate_reset,
+    gate_wait=gate_wait,
     open_gate=open_gate,
     reset_gate=reset_gate,
 )