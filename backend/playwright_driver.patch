--- playwright_driver.py.orig
+++ playwright_driver.py
@@ -22,6 +22,15 @@
 LOGIN_JUMP_ROUTE = "**/_____tmd_____/page/login_jump**"

 # Global flag to control tab closing during login
+_CLOSE_NEW_TABS_DURING_LOGIN = False
+
 # --- add near the top of file ---
 LOGIN_SELECTORS = [
     'text=立即登录',                 # nút cam ở panel phải / góc phải dưới
@@ -32,6 +41,9 @@
     'a[href*="login.1688.com"]',
     'a[href*="login.taobao.com"]',
     'div._buttonWrap_1p2az_60 img[src*="O1CN01ZaHib31lWomw16ded"]'  # nút bạn chỉ định
 ]

 # ========= Helpers =========
@@ -480,6 +492,58 @@
             pass

 async def _is_login_modal_visible(page) -> bool:
+    sels = [
+        'img[src*="qrcode"]',
+        '[class*="login"] [class*="qrcode"]',
+        '[class*="login"] input[type="password"]',
+        '[data-login-version]',           # log bạn có "当前登录弹窗为 1.0.0 版本"
+        'text=扫码登录', 'text=密码登录'
+    ]
+    for s in sels:
+        try:
+            if await page.query_selector(s):
+                return True
+        except:
+            pass
+    return False
+
+async def wait_login_modal_gone(page, stable_ms=1500, timeout_s=120):
+    end = asyncio.get_event_loop().time() + timeout_s
+    last_seen = 0.0
+    while asyncio.get_event_loop().time() < end:
+        if await _is_login_modal_visible(page):
+            last_seen = asyncio.get_event_loop().time()
+            await asyncio.sleep(0.5)
+            continue
+
+        if last_seen > 0:
+            if asyncio.get_event_loop().time() - last_seen >= stable_ms/1000:
+                await _shot(page, 'login_modal_gone')
+                return
+
+        await asyncio.sleep(0.2)
+    raise TimeoutError("Login modal did not disappear stably")
+
 async def _close_overlays(page):
     # đóng vài overlay thường gặp để tránh che click/goto
     for sel in ['.guide-close', '.close-btn', '[aria-label="关闭"]', '.newuser-guide .close', '.pop-close']:
@@ -487,6 +551,28 @@
                 await btn.click()
         except Exception:
             pass
+
+async def wait_for_chat_ready(page, timeout_s: int = 25):
+    sels = [
+        'textarea','[contenteditable="true"]','div[role="textbox"]',
+        '.im-textarea,.msg-editor textarea,.chat-input textarea',
+        'pre.edit[contenteditable="true"]'
+    ]
+    end = asyncio.get_event_loop().time() + timeout_s
+
+    while asyncio.get_event_loop().time() < end:
+        try:
+            # check current page
+            for sel in sels:
+                if await page.query_selector(sel):
+                    await _shot(page, 'chat_input_ready_page')
+                    return True
+
+            # check frames with chat-related URLs
+            for f in page.frames:
+                u = f.url or ''
+                if any(k in u for k in ['im','aliim','chat','message']):
+                    for sel in sels:
+                        if await f.query_selector(sel):
+                            await _shot(page, 'chat_input_ready_iframe')
+                            return True
+        except Exception:
+            pass
+        await asyncio.sleep(0.5)
+    raise TimeoutError("Chat UI not ready")

 # ========= Canonical Actions =========
 async def ensure_login_via_taobao(page, timeout_s: int = 300, next_url: str | None = None, force_show_login: bool = False):
@@ -497,6 +583,11 @@
     })
     await page.goto("https://www.1688.com/", wait_until="domcontentloaded")

+    # Bật flag để đóng tab mới trong login phase
+    global _CLOSE_NEW_TABS_DURING_LOGIN
+    _CLOSE_NEW_TABS_DURING_LOGIN = True
+
     # --- inside ensure_login_via_taobao(...) after goto 1688 and page is idle ---
     # 0) đảm bảo ở homepage và hiển thị vùng nút
     try:
@@ -545,7 +636,7 @@
         if not u:
             await p.wait_for_load_state("domcontentloaded", timeout=5000)
             u = (p.url or "").lower()
-        if ("main.m.tmall.com" in u) or ("shtml/static/wrongpage.html" in u) or ("/_____tmd_____/page/login_jump" in u):
+        if ("main.m.tmall.com" in u) or ("shtml/static/wrongpage.html" in u) or ("/_____tmd_____/page/login_jump" in u):
             await p.close()
     except Exception:
         try: await p.close()
@@ -558,6 +649,13 @@
         # QUAN TRỌNG: luôn reset cờ sau khi xử lý tab mới
                 _pd.ALLOW_TAOBAO_REDIRECT = False

+    # Thêm guard để chặn window.open và navigation khi modal visible
+    await page.add_init_script("""
+      (() => {
+        const guard = () => !!document.querySelector('img[src*="qrcode"],[data-login-version],[class*="login"] input[type="password"]');
+        const ow = window.open; window.open = (...a)=>guard()?null:ow.apply(this,a);
+        const loc = window.location; ['assign','replace','reload'].forEach(k=>{const o=loc[k].bind(loc); loc[k]=(...a)=>guard()?null:o(...a);});
+        const h=history;['pushState','replaceState'].forEach(k=>{const o=h[k].bind(h); h[k]=(...a)=>guard()?null:o(...a);});
+      })();
+    """)
+
     context.on("page", lambda p: asyncio.create_task(_on_new_page(p)))

     page = await context.new_page()
@@ -648,7 +746,7 @@
         # Nếu thấy dấu hiệu đã đăng nhập → hoàn thành login
         if await _looks_logged_in(page):
             await _shot(page, 'logged_in_ui_detected')
-            await _close_overlays(page)
-            break
+            await wait_login_modal_gone(page, stable_ms=1500, timeout_s=120)
+            _CLOSE_NEW_TABS_DURING_LOGIN = False
+            return

         # Chờ captcha/nhập liệu nếu cần
         try:
@@ -656,21 +754,9 @@
         except Exception:
             pass

-        # Chờ nhẹ tránh spam requests
+        await asyncio.sleep(0.5)
+    except Exception:
+        _CLOSE_NEW_TABS_DURING_LOGIN = False
+        raise
+    finally:
+        _CLOSE_NEW_TABS_DURING_LOGIN = False
+
+    # Nếu hết thời gian mà chưa login thành công
+    if not await _looks_logged_in(page):
+        raise RuntimeError("Login not completed in time")
+
+    # Tắt flag đóng tab mới sau khi login xong
+    _CLOSE_NEW_TABS_DURING_LOGIN = False
+
+    # 3) >>> LOGIN DONE: GỠ GUARD để không can thiệp refresh tự động của trang
+    try:
+        await uninstall_loop_guards(page)
+    except Exception:
+        pass
+
+    # Lưu state để lần sau không cần login lại
+    try:
+        await page.context.storage_state(path=STATE_JSON)
+    except Exception:
+        pass
+
+    # 4) Chỉ điều hướng về Work Home nếu không phải force_show_login
+    if not force_show_login:
+        await page.goto(WORK_HOME, wait_until="domcontentloaded")
+        try:
+            await page.wait_for_url(r"^https://work\.1688\.com/", timeout=8000)
+        except Exception:
+            pass
+
+        # >>> STABLE TẠI WORK HOME: giờ mới clear headers
+        await ctx.set_extra_http_headers({})
+
+    return True
+
+
+async def open_chat_from_product_canonical(page, product_url: str, timeout_s: int = 90):
+    try:
+        product_url = normalize_1688_product_url(product_url)
+    except Exception:
+        pass
+
+    await _goto_with_1688_referer(page, product_url)
+    await _shot(page, 'product_opened')
+    await detect_and_wait_captcha(page)
+    selectors = [
+        'od-text[i18n="wangwang"]',  # Thêm selector theo yêu cầu
+        'text=客服','text=联系','text=咨询','text=联系供应商',
+        'button:has-text("客服")','[data-title*=客服]','[aria-label*=客服]',
+        '.contact-supplier,.customer-service,.im-chat,.im-btn'
+    ]
+    for sel in selectors:
+        try:
+            btn = await page.wait_for_selector(sel, timeout=3000)
+            await btn.click()
+            await _shot(page, 'chat_clicked')
+            break
+        except Exception:
+            continue
+
+    try:
+        await page.wait_for_timeout(1000)
+        for f in page.frames:
+            u = f.url or ''
+            if any(k in u for k in ['im','chat','message']):
+                await _shot(page, 'chat_iframe_detected')
+                return True
+    except Exception:
+        pass
+
+    await _shot(page, 'chat_open_attempted')
+    return True
+
+async def send_on_chat_precise_canonical(page, text: str):
+    input_selectors = [
+        'pre.edit[contenteditable="true"]',  # Thêm selector theo yêu cầu
+        'textarea','[contenteditable="true"]','div[role="textbox"]',
+        '.im-textarea,.msg-editor textarea,.chat-input textarea'
+    ]
+    send_selectors = [
+        'text=发送','text=Send','button:has-text("发送")','button:has-text("Send")',
+        '.send-btn,.im-send-btn,.chat-send-btn'
+    ]
+
+    typed = False
+    for sel in input_selectors:
+        try:
+            el = await page.wait_for_selector(sel, timeout=2000)
+            await el.click(); await el.fill(''); await el.type(text)
+            await _shot(page, 'chat_text_typed'); typed = True; break
+        except Exception:
+            continue
+    if not typed:
+        raise RuntimeError('No chat input found')
+
+    for sel in send_selectors:
+        try:
+            btn = await page.wait_for_selector(sel, timeout=1500)
+            await btn.click(); await _shot(page, 'chat_text_sent_btn'); return True
+        except Exception:
+            continue
+
+    try:
+        await page.keyboard.press('Enter')
+        await _shot(page, 'chat_text_sent_enter')
+        return True
+    except Exception:
+        pass
+
+    raise RuntimeError('Could not send message (send_on_chat_precise_canonical)')
+
+async def wait_for_supplier_reply_canonical(page, timeout_s: int = 180):
+    end = asyncio.get_event_loop().time() + timeout_s
+    last_shot_t = 0
+    known_texts = set()
+    while asyncio.get_event_loop().time() < end:
+        try:
+            # Phát hiện tin nhắn từ supplier qua nhiều selector
+            selectors = [
+                '.message,.msg-bubble,.chat-msg,.message-item',  # các selector cũ
+                'div.nick'  # Thêm selector theo yêu cầu để đợi supplier reply
+            ]
+
+            all_texts = []
+            supplier_replied = False
+
+            for sel in selectors:
+                try:
+                    elements = await page.query_selector_all(sel)
+                    for el in elements[:50]:
+                        try:
+                            t = (await el.inner_text())[:200].strip()
+                            if t:
+                                all_texts.append(t)
+                                # Kiểm tra đặc tả supplier (div.nick có text như "中盛未来通讯")
+                                if sel == 'div.nick' and any(c in t for c in "中盛未来通讯"):
+                                    supplier_replied = True
+                        except Exception:
+                            pass
+                except Exception:
+                    pass
+
+            # Loại bỏ trùng lặp
+            texts = list(set(all_texts))
+            new_ones = [t for t in texts if t not in known_texts]
+
+            # Nếu có tin nhắn mới hoặc supplier reply xác nhận qua div.nick
+            if new_ones or supplier_replied:
+                known_texts.update(new_ones)
+                await _shot(page, 'reply_detected')
+                return {'new_messages': new_ones[:5], 'supplier_replied': supplier_replied}
+        except Exception:
+            pass
+
+        now = asyncio.get_event_loop().time()
+        if now - last_shot_t > 10:
+            await _shot(page, 'reply_waiting')
+            last_shot_t = now
         await asyncio.sleep(0.5)
-    # Tắt flag đóng tab mới sau khi login xong
-    _CLOSE_NEW_TABS_DURING_LOGIN = False
-
-    # Nếu hết thời gian mà chưa login thành công
-    if not await _looks_logged_in(page):
-        raise RuntimeError("Login not completed in time")
-
-    # 3) >>> LOGIN DONE: GỠ GUARD để không can thiệp refresh tự động của trang
-    try:
-        await uninstall_loop_guards(page)
-    except Exception:
-        pass
-
-    # Lưu state để lần sau không cần login lại
-    try:
-        await page.context.storage_state(path=STATE_JSON)
-    except Exception:
-        pass
-
-    # 4) Chỉ điều hướng về Work Home nếu không phải force_show_login
-    if not force_show_login:
-        await page.goto(WORK_HOME, wait_until="domcontentloaded")
-        try:
-            await page.wait_for_url(r"^https://work\.1688\.com/", timeout=8000)
-        except Exception:
-            pass
-
-        # >>> STABLE TẠI WORK HOME: giờ mới clear headers
-        await ctx.set_extra_http_headers({})
-
-    return True
-
-
-async def open_chat_from_product_canonical(page, product_url: str, timeout_s: int = 90):
-    try:
-        product_url = normalize_1688_product_url(product_url)
-    except Exception:
-        pass
-
-    await _goto_with_1688_referer(page, product_url)
-    await _shot(page, 'product_opened')
-    await detect_and_wait_captcha(page)
-    selectors = [
-        'od-text[i18n="wangwang"]',  # Thêm selector theo yêu cầu
-        'text=客服','text=联系','text=咨询','text=联系供应商',
-        'button:has-text("客服")','[data-title*=客服]','[aria-label*=客服]',
-        '.contact-supplier,.customer-service,.im-chat,.im-btn'
-    ]
-    for sel in selectors:
-        try:
-            btn = await page.wait_for_selector(sel, timeout=3000)
-            await btn.click()
-            await _shot(page, 'chat_clicked')
-            break
-        except Exception:
-            continue
-
-    try:
-        await page.wait_for_timeout(1000)
-        for f in page.frames:
-            u = f.url or ''
-            if any(k in u for k in ['im','chat','message']):
-                await _shot(page, 'chat_iframe_detected')
-                return True
-    except Exception:
-        pass
-
-    await _shot(page, 'chat_open_attempted')
-    return True
-
-async def send_on_chat_precise_canonical(page, text: str):
-    input_selectors = [
-        'pre.edit[contenteditable="true"]',  # Thêm selector theo yêu cầu
-        'textarea','[contenteditable="true"]','div[role="textbox"]',
-        '.im-textarea,.msg-editor textarea,.chat-input textarea'
-    ]
-    send_selectors = [
-        'text=发送','text=Send','button:has-text("发送")','button:has-text("Send")',
-        '.send-btn,.im-send-btn,.chat-send-btn'
-    ]
-
-    typed = False
-    for sel in input_selectors:
-        try:
-            el = await page.wait_for_selector(sel, timeout=2000)
-            await el.click(); await el.fill(''); await el.type(text)
-            await _shot(page, 'chat_text_typed'); typed = True; break
-        except Exception:
-            continue
-    if not typed:
-        raise RuntimeError('No chat input found')
-
-    for sel in send_selectors:
-        try:
-            btn = await page.wait_for_selector(sel, timeout=1500)
-            await btn.click(); await _shot(page, 'chat_text_sent_btn'); return True
-        except Exception:
-            continue
-
-    try:
-        await page.keyboard.press('Enter')
-        await _shot(page, 'chat_text_sent_enter')
-        return True
-    except Exception:
-        pass
-
-    raise RuntimeError('Could not send message (send_on_chat_precise_canonical)')
-
-async def wait_for_supplier_reply_canonical(page, timeout_s: int = 180):
-    end = asyncio.get_event_loop().time() + timeout_s
-    last_shot_t = 0
-    known_texts = set()
-    while asyncio.get_event_loop().time() < end:
-        try:
-            # Phát hiện tin nhắn từ supplier qua nhiều selector
-            selectors = [
-                '.message,.msg-bubble,.chat-msg,.message-item',  # các selector cũ
-                'div.nick'  # Thêm selector theo yêu cầu để đợi supplier reply
-            ]
-
-            all_texts = []
-            supplier_replied = False
-
-            for sel in selectors:
-                try:
-                    elements = await page.query_selector_all(sel)
-                    for el in elements[:50]:
-                        try:
-                            t = (await el.inner_text())[:200].strip()
-                            if t:
-                                all_texts.append(t)
-                                # Kiểm tra đặc tả supplier (div.nick có text như "中盛未来通讯")
-                                if sel == 'div.nick' and any(c in t for c in "中盛未来通讯"):
-                                    supplier_replied = True
-                        except Exception:
-                            pass
-                except Exception:
-                    pass
-
-            # Loại bỏ trùng lặp
-            texts = list(set(all_texts))
-            new_ones = [t for t in texts if t not in known_texts]
-
-            # Nếu có tin nhắn mới hoặc supplier reply xác nhận qua div.nick
-            if new_ones or supplier_replied:
-                known_texts.update(new_ones)
-                await _shot(page, 'reply_detected')
-                return {'new_messages': new_ones[:5], 'supplier_replied': supplier_replied}
-        except Exception:
-            pass
-
-        now = asyncio.get_event_loop().time()
-        if now - last_shot_t > 10:
-            await _shot(page, 'reply_waiting')
-            last_shot_t = now
-        await asyncio.sleep(1.0)
-    raise TimeoutError('No supplier reply in time (wait_for_supplier_reply_canonical)')
 def normalize_1688_product_url(raw: str) -> str:
     """
     Nhận mọi dạng product input -> trả về URL chuẩn:
@@ -1120,6 +1226,7 @@
     send_on_chat_precise_canonical=send_on_chat_precise_canonical,
     wait_for_supplier_reply_canonical=wait_for_supplier_reply_canonical,
     wait_for_chat_ready=wait_for_chat_ready,
     normalize_1688_product_url=normalize_1688_product_url,
     stable_goto_with_referer=stable_goto_with_referer,
 )