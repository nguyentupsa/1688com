--- app.py.orig
+++ app.py
@@ -7,6 +7,7 @@
 from contextlib import asynccontextmanager

 from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, Query
 from starlette.websockets import WebSocketState
 from fastapi.middleware.cors import CORSMiddleware
 from fastapi.responses import JSONResponse
 from fastapi.responses import JSONResponse
 import uvicorn
+import traceback

 from models import (
@@ -219,6 +220,7 @@
 @app.post("/api/negotiate/start")
 async def start_negotiation(request: NegotiationRequest) -> NegotiationStartResponse:
     """Start a new negotiation session."""
     try:
+        logger.info("[API] Starting negotiation request")
         if state_machine.is_running():
             current_state_value = getattr(state_machine.current_session, "current_state", None)
+            logger.warning(f"[API] Negotiation already in progress, current state: {current_state_value}")
             return NegotiationStartResponse(
                 ok=False,
                 message="Another negotiation is already in progress",
                 current_state=current_state_value
             )

@@ -260,6 +262,9 @@
         # Start negotiation (this is the real API)
         result = await state_machine.start(product_url, opener_text, int(max_turns), style)
+        logger.info(f"[API] Negotiation started successfully: {result.get('session_id')}")
         return NegotiationStartResponse(
             ok=True,
             session_id=getattr(state_machine.current_session, "id", None),
             message=f"Session started: {result.get('session_id')}",
             current_state=getattr(state_machine.current_session, "current_state", None)
         )

     except Exception as e:
+        logger.error(f"[API] Error starting negotiation:\n{traceback.format_exc()}")
         return NegotiationStartResponse(
             ok=False,
             message=f"Failed to start negotiation: {str(e)}"
         )

 @app.post("/api/negotiate/stop")
 async def stop_negotiation():
     """Stop the current negotiation."""
     try:
+        logger.info("[API] Stopping negotiation request")
         if not state_machine.is_running():
+            logger.info("[API] No negotiation in progress to stop")
             return {"ok": True, "message": "No negotiation in progress"}

         await state_machine.stop_negotiation()
+        logger.info("[API] Negotiation stopped successfully")
         return {"ok": True, "message": "Negotiation stopped successfully"}

     except Exception as e:
+        logger.error(f"[API] Error stopping negotiation:\n{traceback.format_exc()}")
         return {"ok": False, "message": f"Failed to stop negotiation: {str(e)}"}

 @app.post("/api/session/login-only")
 async def login_only():
     """Start login-only session that stops at Work Home."""
     try:
+        logger.info("[API] Starting login-only session")
         if state_machine.is_running():
+            logger.warning("[API] Another session is already running")
             return {"ok": False, "message": "Another session is already running"}

         logger.info("[API] Starting login-only session")
         result = await state_machine.start_login_only()
+        logger.info("[API] Login-only session started successfully")
         return {
             "ok": True,
             "message": "Login session started successfully",
             "result": result
         }

     except Exception as e:
+        logger.error(f"[API] Error starting login-only session:\n{traceback.format_exc()}")
         return {"ok": False, "message": f"Failed to start login session: {str(e)}"}

 @app.post("/api/session/goto-product")
 async def goto_product(request: Dict[str, str]):
     """Navigate to product URL with existing session."""
     try:
+        logger.info("[API] Navigate to product request")
         if not state_machine.is_running():
+            logger.warning("[API] No active session for product navigation")
             return {"ok": False, "message": "No active session"}

         product_url = request.get("product_url", "")
         if not product_url:
+            logger.warning("[API] Missing product_url in request")
             raise HTTPException(status_code=400, detail="product_url is required")

         logger.info(f"[API] Navigating to product: {product_url}")
         result = await state_machine.goto_product(product_url)
+        logger.info("[API] Successfully navigated to product")
         return {
             "ok": True,
             "message": "Successfully navigated to product",
             "result": result
         }

     except Exception as e:
+        logger.error(f"[API] Error navigating to product:\n{traceback.format_exc()}")
         return {"ok": False, "message": f"Failed to navigate to product: {str(e)}"}

 @app.post("/api/gate/open")
 async def api_gate_open(name: str = Query(..., min_length=3)):
+    logger.info(f"[API] Opening gate: {name}")
     try:
         from state_machine import gate_open
         gate_open(name)
+        logger.info(f"[API] Gate opened successfully: {name}")
         return {"ok": True, "gate": name}
     except Exception as e:
+        logger.error(f"[API] Error opening gate {name}:\n{traceback.format_exc()}")
         return {"ok": False, "message": f"Failed to open gate: {str(e)}"}

 @app.post("/api/gate/reset")
 async def api_gate_reset(name: str = Query(..., min_length=3)):
+    logger.info(f"[API] Resetting gate: {name}")
     try:
         from state_machine import gate_reset
         gate_reset(name)
+        logger.info(f"[API] Gate reset successfully: {name}")
         return {"ok": True, "gate": name}
     except Exception as e:
+        logger.error(f"[API] Error resetting gate {name}:\n{traceback.format_exc()}")
         return {"ok": False, "message": f"Failed to reset gate: {str(e)}"}

 @app.get("/api/negotiation/status")
 async def get_negotiation_status():
     """Get current negotiation status."""
     try:
         if not getattr(state_machine.current_session, "id", None):
+            logger.info("[API] No active negotiation session")
             return {
                 "active": False,
                 "message": "No active negotiation"
             }

         session = state_machine.current_session
+        logger.info(f"[API] Negotiation status - State: {session.current_state}, Turn: {session.turn}")
         return {
             "active": state_machine.is_running(),
             "session_id": session.id,
             "current_state": session.current_state,   # string
             "current_turn": session.turn,
             "max_turns": session.max_turns,
             "product_url": session.product_url,
             "total_turns": session.turn,             # tạm dùng turn làm tổng lượt
             "created_at": session.started_at,        # state tracks started_at/finished_at
             "started_at": session.started_at,
             "error_message": session.last_error
         }
     except Exception as e:
+        logger.error(f"[API] Error getting negotiation status:\n{traceback.format_exc()}")
         return {"active": False, "message": f"Error getting status: {str(e)}"}

 @app.get("/api/artifacts")
 async def list_artifacts():
     """List all available negotiation artifacts."""
     try:
+        logger.info("[API] Listing negotiation artifacts")
         data_dir = settings.data_dir
         if not os.path.exists(data_dir):
+            logger.info("[API] No data directory found")
             return {"sessions": []}

         sessions = []
         for item in os.listdir(data_dir):
             if item.startswith("session_") and os.path.isdir(os.path.join(data_dir, item)):
                 session_path = os.path.join(data_dir, item)

@@ -395,6 +410,7 @@
         # Sort by creation time (newest first)
         sessions.sort(key=lambda x: x.get("created_at", ""), reverse=True)
+        logger.info(f"[API] Found {len(sessions)} sessions")
         return {"sessions": sessions}

     except Exception as e:
+        logger.error(f"[API] Error listing artifacts:\n{traceback.format_exc()}")
         return {"sessions": []}

 @app.post("/api/generate-opener")
 async def generate_opening_message(request: Dict[str, str]):
     """Generate AI-powered opening message for negotiation."""
     try:
+        logger.info("[API] Generating opening message")
         product_url = request.get("product_url", "")
         if not product_url:
+            logger.warning("[API] Missing product_url for opener generation")
             raise HTTPException(status_code=400, detail="product_url is required")

         logger.info(f"[API] Generating opener for: {product_url}")
@@ -427,6 +443,7 @@
         return {
             "ok": True,
             "text": opener.encode('utf-8').decode('utf-8'),
             "is_mock": True
         }

     except HTTPException:
         raise
     except Exception as e:
+        logger.error(f"[API] Error generating opener:\n{traceback.format_exc()}")
         return {
             "ok": False,
             "text": "你好，我想了解这款产品的价格和起订量信息。",
             "is_mock": True
         }

 @app.get("/api/artifacts/{session_id}")
 async def get_session_artifacts(session_id: str):
     """Get detailed artifacts for a specific session."""
     try:
+        logger.info(f"[API] Getting artifacts for session: {session_id}")
         session_path = os.path.join(settings.data_dir, session_id)
         if not os.path.exists(session_path):
+            logger.warning(f"[API] Session not found: {session_id}")
             raise HTTPException(status_code=404, detail="Session not found")

         artifacts = {}
@@ -444,16 +461,20 @@
         return artifacts

     except HTTPException:
         raise
     except Exception as e:
+        logger.error(f"[API] Error getting session artifacts:\n{traceback.format_exc()}")
         raise HTTPException(status_code=500, detail=f"Failed to get artifacts: {str(e)}")

 @app.websocket("/ws/logs")
 async def websocket_endpoint(websocket: WebSocket):
     """WebSocket endpoint for real-time log streaming."""
+    logger.info("[WS] New WebSocket connection")
     await manager.connect(websocket)
     try:
         # Send initial status
         await websocket.send_text(json.dumps({
             "type": "status",
             "message": "Connected to negotiation server",
             "timestamp": datetime.now().isoformat()
         }))

         # Keep connection alive and handle incoming messages
         while True:
             try:
                 # Wait for client message with timeout to avoid hanging
                 data = await asyncio.wait_for(websocket.receive_text(), timeout=30.0)

@@ -473,10 +494,12 @@
                         if state_machine.is_running():
                             await state_machine.stop_negotiation()
                             await websocket.send_text(json.dumps({
                                 "type": "status",
                                 "message": "Negotiation stopped by user",
                                 "timestamp": datetime.now().isoformat()
                             }))
                 except json.JSONDecodeError:
                     # Not JSON, ignore
+                    logger.debug("[WS] Received non-JSON message")
                     pass

             except asyncio.TimeoutError:
                 # Send periodic ping to keep connection alive
                 try:
                     await websocket.send_text(json.dumps({
                         "type": "ping",
                         "timestamp": datetime.now().isoformat()
                     }))
                 except Exception:
                     break
             except WebSocketDisconnect:
+                logger.info("[WS] Client disconnected cleanly")
                 break
             except Exception as e:
+                logger.warning(f"[WS] Error handling message: {e}")
                 break

     except WebSocketDisconnect:
+        logger.info("[WS] WebSocket disconnected during handshake")
     except Exception as e:
+        logger.error(f"[WS] WebSocket error: {e}")
     finally:
         manager.disconnect(websocket)